#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <pthread.h>

#define RED "\033[0;31m"
#define GREEN "\033[32m"
#define DF "\033[0m"
#define YELLOW "\x1b[33m"

#define MAX 100
#define MAX_CHILD 5
#define RD 0
#define WR 1

//Global variable
int isChild;
char command[MAX];
char msg_saved[MAX];
pthread_t t_id;
int tot_figli=0;
int mypos;
int children[MAX_CHILD];
int openedFile;
int segnale;
int pidFather;

int pipe1[MAX_CHILD][2];


//Funzioni
void signalIntHandler(int signo){

    if(getpid()!=pidFather){
        return;
    }
    
    //Issue termination signal to all children
    for(int i=0;i<tot_figli;i++){
        printf("kill: %d\n",children[i]);
        kill(children[i],SIGTERM);
    }
            

    //Wait children termination
    while(wait(NULL)>0);

    printf("Terminating\n");

    //Terminate
    exit(0);
}

void* my_func(void* param){
    char messaggio[MAX];
    char tmp[10];
    openedFile=open("tmp/log.txt",O_CREAT|O_RDWR|O_APPEND,S_IRUSR|S_IWUSR);
    strcpy(messaggio,RED);
    strcat(messaggio,"[THREAD] I'm a new thread generated by signal ");
    sprintf(tmp,"%d",segnale);
    strcat(messaggio,tmp);
    strcat(messaggio,"\n[THREAD] Sending message to children \n");
    write(openedFile,messaggio,strlen(messaggio));
    close(openedFile);
    
    for(int i=0;i<tot_figli;i++){
        strcpy(messaggio,"To Child ");
        sprintf(tmp,"%d",i);
        strcat(messaggio,tmp);
        strcat(messaggio," PID ");
        sprintf(tmp,"%d",children[i]);
        strcat(messaggio,tmp);
        strcat(messaggio,": ");
        strcat(messaggio,msg_saved);
        write(pipe1[i][WR],messaggio,sizeof(messaggio));
    }
        
    tot_figli=0;          
    openedFile=open("tmp/log.txt",O_CREAT|O_RDWR|O_APPEND,S_IRUSR|S_IWUSR);
    strcpy(messaggio,RED);
    strcat(messaggio,"[THREAD] Children reset\n");
    strcat(messaggio,"[THREAD] Termination thread \n");
    write(openedFile,messaggio,strlen(messaggio));
    close(openedFile);          
    return (void *)3;
}

void handler(int signo){
    segnale=signo;
    pthread_create(&t_id,NULL,my_func,NULL);
}


int main(int argc,char** argv){
    mkdir("tmp",0666);
    //Print father PID
    printf("%s[MAIN] my id is %d %s\n",GREEN,getpid(),DF);
    pidFather=getpid();
    signal(SIGINT,signalIntHandler);
    signal(SIGUSR1,handler);
    signal(SIGUSR2,handler);



    while(1){
        fgets(command,MAX,stdin); fflush(stdin);

        if(atoi(command)>0){
            if(tot_figli<=MAX_CHILD){
                pipe(pipe1[tot_figli]);
                children[tot_figli]=fork();
                if(children[tot_figli]==0){
                    mypos=tot_figli;
                    close(pipe1[tot_figli][WR]); //Close writing end of pipe_figlio pipe (child's pipe_padre)
                    printf("%s[CHD] I'm a new children with id %d ,and I'm waiting for msg from my father%s\n",YELLOW,getpid(),DF);
                    break;
                }
                else{
                    close(pipe1[tot_figli][RD]); //Close writing end of pipe_padre pipe
                    sleep(1);
                    tot_figli++;
                }
            }
            else{
                printf("%s[MAIN] Too many children. Send msg to free them %s\n",GREEN,DF);
            }
        }
        else{
            printf("%s[MAIN] msg saved%s\n",GREEN,DF);
            strcpy(msg_saved,command);
        }
    }
    char mesg[MAX];
    while(1){
        fflush(stdout);
        fflush(stdin);
        read(pipe1[mypos][RD],&mesg,50);
        printf("%s[CHD] I received the following message: %s%s\n",YELLOW,mesg,DF);
        exit(0);
    }
}